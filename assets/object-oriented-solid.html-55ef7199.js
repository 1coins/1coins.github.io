import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as s,c as l,a as e,b as t,d as r,e as c}from"./app-3e6d2d9d.js";const a={},d=e("p",null,[e("code",null,"S.O.L.I.D"),t("是面向对象设计和编程（"),e("code",null,"OOD&OOP"),t("）中几个重要编码原则（"),e("code",null,"Programming Priciple"),t("）的首字母缩写。")],-1),h=e("thead",null,[e("tr",null,[e("th",{style:{"text-align":"center"}},"简称"),e("th",{style:{"text-align":"center"}},"书籍"),e("th",{style:{"text-align":"center"}},"名称")])],-1),p=e("td",{style:{"text-align":"center"}},[e("strong",null,"SRP")],-1),g={style:{"text-align":"center"}},_={href:"http://www.objectmentor.com/resources/articles/srp.pdf",target:"_blank",rel:"noopener noreferrer"},f=e("br",null,null,-1),u=e("td",{style:{"text-align":"center"}},"单一责任原则",-1),b=e("td",{style:{"text-align":"center"}},[e("strong",null,"OCP")],-1),m={style:{"text-align":"center"}},x={href:"http://www.objectmentor.com/resources/articles/ocp.pdf",target:"_blank",rel:"noopener noreferrer"},y=e("br",null,null,-1),S=e("td",{style:{"text-align":"center"}},"开放封闭原则",-1),w=e("td",{style:{"text-align":"center"}},[e("strong",null,"LSP")],-1),P={style:{"text-align":"center"}},v={href:"http://www.objectmentor.com/resources/articles/lsp.pdf",target:"_blank",rel:"noopener noreferrer"},k=e("td",{style:{"text-align":"center"}},"里氏替换原则",-1),O=e("td",{style:{"text-align":"center"}},[e("strong",null,"DIP")],-1),j={style:{"text-align":"center"}},E={href:"http://www.objectmentor.com/resources/articles/dip.pdf",target:"_blank",rel:"noopener noreferrer"},I=e("td",{style:{"text-align":"center"}},"依赖倒置原则",-1),D=e("td",{style:{"text-align":"center"}},[e("strong",null,"ISP")],-1),L={style:{"text-align":"center"}},T={href:"http://www.objectmentor.com/resources/articles/isp.pdf",target:"_blank",rel:"noopener noreferrer"},N=e("td",{style:{"text-align":"center"}},"接口分离原则",-1),R={href:"http://stevesmithblog.com/",target:"_blank",rel:"noopener noreferrer"},C={href:"http://stevesmithblog.com/blog/teched-2009-session-aftermath/",target:"_blank",rel:"noopener noreferrer"},A={href:"http://www.lostechies.com/members/derick.bailey/default.aspx",target:"_blank",rel:"noopener noreferrer"},V={href:"http://www.lostechies.com/blogs/derickbailey/archive/2009/02/11/solid-development-principles-in-motivational-pictures.aspx",target:"_blank",rel:"noopener noreferrer"},z=c('<h1 id="单一责任原则" tabindex="-1"><a class="header-anchor" href="#单一责任原则" aria-hidden="true">#</a> 单一责任原则</h1><p>当需要修改某个类的时候原因有且只有一个（<code>THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE</code>）。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。</p><figure><img src="https://cdn.jsdelivr.net/gh/1coins/assets/object-oriented-solid/srp.png" alt="" tabindex="0" loading="lazy"><figcaption>Single Responsibility Principle</figcaption></figure><h1 id="开放封闭原则" tabindex="-1"><a class="header-anchor" href="#开放封闭原则" aria-hidden="true">#</a> 开放封闭原则</h1><p>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。</p><figure><img src="https://cdn.jsdelivr.net/gh/1coins/assets/object-oriented-solid/ocp.png" alt="" tabindex="0" loading="lazy"><figcaption>Open Closed Principle</figcaption></figure><h1 id="里氏替换原则" tabindex="-1"><a class="header-anchor" href="#里氏替换原则" aria-hidden="true">#</a> 里氏替换原则</h1><p>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有<code>is-a</code>关系。</p><figure><img src="https://cdn.jsdelivr.net/gh/1coins/assets/object-oriented-solid/lsp.png" alt="" tabindex="0" loading="lazy"><figcaption>Liskov Subtitution Principle</figcaption></figure><h1 id="依赖倒置原则" tabindex="-1"><a class="header-anchor" href="#依赖倒置原则" aria-hidden="true">#</a> 依赖倒置原则</h1><ol><li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</li><li>抽象不应该依赖于细节，细节应该依赖于抽象</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/1coins/assets/object-oriented-solid/dip.png" alt="" tabindex="0" loading="lazy"><figcaption>Dependency Inversion Principle</figcaption></figure><h1 id="接口分离原则" tabindex="-1"><a class="header-anchor" href="#接口分离原则" aria-hidden="true">#</a> 接口分离原则</h1><p>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。</p><figure><img src="https://cdn.jsdelivr.net/gh/1coins/assets/object-oriented-solid/isp.png" alt="" tabindex="0" loading="lazy"><figcaption>Interface Segregation Principle</figcaption></figure><p>这几条原则是非常基础而且重要的面向对象设计原则，正是由于这些原则的基础性，理解、融汇贯通这些原则需要不少的经验和知识的积累，上述的图片很好的注释了这几条原则。</p><p>‍</p>',17);function B(H,M){const n=o("ExternalLinkIcon");return s(),l("div",null,[d,e("table",null,[h,e("tbody",null,[e("tr",null,[p,e("td",g,[e("a",_,[t("The Single Responsibility Principle"),r(n)]),f]),u]),e("tr",null,[b,e("td",m,[e("a",x,[t("The Open Closed Principle"),r(n)]),y]),S]),e("tr",null,[w,e("td",P,[e("a",v,[t("The Liskov Substitution Principle"),r(n)])]),k]),e("tr",null,[O,e("td",j,[e("a",E,[t("The Dependency Inversion Principle"),r(n)])]),I]),e("tr",null,[D,e("td",L,[e("a",T,[t("The Interface Segregation Principle"),r(n)])]),N])])]),e("p",null,[e("a",R,[t("Steve Smith"),r(n)]),t("在5月份的微软TechED 2009上有个"),e("a",C,[t("SOLIDify Your ASP.NET MVC"),r(n)]),t("的讲座, "),e("a",A,[t("derick.bailey"),r(n)]),t("的"),e("a",V,[t("SOLID Development Principles – In Motivational Pictures"),r(n)]),t("很好的解释了SOLID原则。")]),z])}const U=i(a,[["render",B],["__file","object-oriented-solid.html.vue"]]);export{U as default};
